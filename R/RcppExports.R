# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Discretization of an univariate density
#'
#' Discretizates an univariate density function using Simposon rule
#' @param density the density function
#' @param parameters parameters of the density function
#' @param ini_point initial value for the discretization
#' @param truncation_point max value for the discretization
#' @param max_probability maximum probability of a discrete point
#' @param max_deltat maximum size of interval
#' @return List with values and weights
discretizate_density <- function(density, parameters, ini_point, truncation_point, max_deltat, max_probability) {
    .Call(`_phfrailty_discretizate_density`, density, parameters, ini_point, truncation_point, max_deltat, max_probability)
}

#' Discretization of an bivariate density
#'
#' Discretizates an bivariate density function using Simposon rule
#' @param density the density function
#' @param parameters parameters of the density function
#' @param ini_point1 max value for the discretization - first component
#' @param truncation_point1 max value for the discretization - first component
#' @param max_deltat1 maximum size of interval - first component
#' @param ini_point2 max value for the discretization - second component
#' @param truncation_point2 max value for the discretization - second component
#' @param max_deltat2 maximum size of interval - second component
#' @param max_probability maximum probability of a discrete point
#' @return List with values and weights
discretizate_bivdensity <- function(density, parameters, ini_point1, truncation_point1, max_deltat1, ini_point2, truncation_point2, max_deltat2, max_probability) {
    .Call(`_phfrailty_discretizate_bivdensity`, density, parameters, ini_point1, truncation_point1, max_deltat1, ini_point2, truncation_point2, max_deltat2, max_probability)
}

#' L_inf norm of a matrix
#'
#' Computes the inf norm of a matrix A, defined as
#' L-oo A =  max ( 1 <= I <= M ) sum ( 1 <= J <= N ) abs ( A(I,J) ).
#' @param A a matrix
#' @return The norm
#'
inf_norm <- function(A) {
    .Call(`_phfrailty_inf_norm`, A)
}

#' Matrix exponential algorithm
#'
#' MATLAB's built-in algorithm - Pade approximation
#' @param A a matrix
#' @return exp(A)
#'
matrix_exponential <- function(A) {
    .Call(`_phfrailty_matrix_exponential`, A)
}

#' Computes A^n
#'
#' @param A a matrix
#' @param n an integer
#' @return A^n
#' @export
matrix_power <- function(n, A) {
    .Call(`_phfrailty_matrix_power`, n, A)
}

#' Computes elements S^n until the value size
#' @param theVector a vector
#' @param S sub-intensity matrix
#' @param sizevect size of vector
vector_of_matrices <- function(theVector, S, sizevect) {
    invisible(.Call(`_phfrailty_vector_of_matrices`, theVector, S, sizevect))
}

#' Creates the matrix  (A1, B1 ; 0, A2)
#'
#' @param A1 a matrix
#' @param A2 a matrix
#' @param B1 a matrix
#' @return the matrix (A1, B1 ; 0, A2)
#'
matrix_VanLoan <- function(A1, A2, B1) {
    .Call(`_phfrailty_matrix_VanLoan`, A1, A2, B1)
}

#' EM using Matlab algorithm for matrix exponential in combination with Armadillo
#'
#' @param alpha initial probabilities
#' @param S sub-intensity
#' @param obs the observations
#' @param weight the weights for the observations
#' @return fitted alpha and S after one iteration
#' @export
EMstep_PADE <- function(alpha, S, obs, weight) {
    invisible(.Call(`_phfrailty_EMstep_PADE`, alpha, S, obs, weight))
}

#' EM  for bivariate PH using Matlab algorithm for matrix exponential
#'
#' @param alpha initial probabilities
#' @param S11 sub-intensity
#' @param S12 a matrix
#' @param S22 sub-intensity
#' @param obs the observations
#' @param weight the weights for the observations
#' @return fitted alpha, S11, S12 and S22 after one iteration
#' @export
EMstep_bivph <- function(alpha, S11, S12, S22, obs, weight) {
    invisible(.Call(`_phfrailty_EMstep_bivph`, alpha, S11, S12, S22, obs, weight))
}

#' Phase-type density
#'
#' Computes the density of a phase-type distribution with parameters \code{alpha} and \code{S} at \code{x}
#' @param x non-negative value
#' @param alpha vector of initial probabilities
#' @param S sub-intensity matrix
#' @return The density at \code{x}
#' @export
ph_density <- function(x, alpha, S) {
    .Call(`_phfrailty_ph_density`, x, alpha, S)
}

#' Phase-type cdf or tail
#'
#' Computes the cdf or tail of a phase-type distribution with parameters \code{alpha} and \code{S} at \code{x}
#' @param x non-negative values
#' @param alpha vector of initial probabilities
#' @param S sub-intensity matrix
#' @param lower_tail cdf or tail
#' @return The density at \code{x}
#' @export
ph_cdf <- function(x, alpha, S, lower_tail = TRUE) {
    .Call(`_phfrailty_ph_cdf`, x, alpha, S, lower_tail)
}

#' Laplace transform of a phase-type distribution
#'
#' Computes the Laplace transform at \code{r} of a phase-type distribution with parameters \code{alpha} and \code{S}
#' @param r real value
#' @param alpha vector of initial probabilities
#' @param S sub-intensity matrix
#' @return Laplace transform at \code{r}
#' @export
#' @examples
#' alpha <- c(0.5, 0.3, 0.2)
#' S <- matrix(c(c(-1, 0, 0), c(1, -2, 0),c(0, 1, -5)), nrow = 3, ncol = 3)
#' ph_laplace(0.5, alpha, S)
ph_laplace <- function(r, alpha, S) {
    .Call(`_phfrailty_ph_laplace`, r, alpha, S)
}

#' Derivative of order n of the Laplace transform of a phase-type distribution without the multiplying constant
#'
#' Computes the derivative of order n (without the multiplying constant) of the Laplace transform at \code{r} of a phase-type distribution with parameters \code{alpha} and \code{S}
#' @param r real value
#' @param n an integer
#' @param alpha vector of initial probabilities
#' @param S sub-intensity matrix
#' @return Laplace transform at \code{r}
#' @export
#' @examples
#' alpha <- c(0.5, 0.3, 0.2)
#' S <- matrix(c(c(-1, 0, 0), c(1, -2, 0),c(0, 1, -5)), nrow = 3, ncol = 3)
#' ph_laplace_der_nocons(0.5, 2, alpha, S)
ph_laplace_der_nocons <- function(r, n, alpha, S) {
    .Call(`_phfrailty_ph_laplace_der_nocons`, r, n, alpha, S)
}

#' Bivariate phase-type joint density
#'
#' @param x matrix of values
#' @param alpha vector of initial probabilities
#' @param S11 sub-intensity matrix
#' @param S12 matrix
#' @param S22 sub-intensity matrix
#' @return Joint density at \code{x}
#' @export
#' @examples
#' alpha <- c(0.15, 0.85)
#' S11 <- matrix(c(c(-2, 9), c(0, -11)), nrow = 2, ncol = 2)
#' S12 <- matrix(c(c(2, 0), c(0, 2)), nrow = 2, ncol = 2)
#' S22 <- matrix(c(c(-1, 0), c(0.5, -5)), nrow = 2, ncol = 2)
#' x <- matrix(c(c(0.5, 1), c(2, 1.5)), ncol = 2)
#' bivph_density(x, alpha, S11, S12, S22)
bivph_density <- function(x, alpha, S11, S12, S22) {
    .Call(`_phfrailty_bivph_density`, x, alpha, S11, S12, S22)
}

#' Bivariate phase-type joint tail
#'
#' @param x matrix of values
#' @param alpha vector of initial probabilities
#' @param S11 sub-intensity matrix
#' @param S12 matrix
#' @param S22 sub-intensity matrix
#' @return Joint tail at \code{x}
#' @export
#' @examples
#' alpha <- c(0.15, 0.85)
#' S11 <- matrix(c(c(-2, 9), c(0, -11)), nrow = 2, ncol = 2)
#' S12 <- matrix(c(c(2, 0), c(0, 2)), nrow = 2, ncol = 2)
#' S22 <- matrix(c(c(-1, 0), c(0.5, -5)), nrow = 2, ncol = 2)
#' x <- matrix(c(c(0.5, 1), c(2, 1.5)), ncol = 2)
#' bivph_tail(x, alpha, S11, S12, S22)
bivph_tail <- function(x, alpha, S11, S12, S22) {
    .Call(`_phfrailty_bivph_tail`, x, alpha, S11, S12, S22)
}

#' Bivariate phase-type joint Laplace
#'
#' @param r matrix of values
#' @param alpha vector of initial probabilities
#' @param S11 sub-intensity matrix
#' @param S12 matrix
#' @param S22 sub-intensity matrix
#' @return Joint laplace at \code{r}
#' @export
#' @examples
#' alpha <- c(0.15, 0.85)
#' S11 <- matrix(c(c(-2, 9), c(0, -11)), nrow = 2, ncol = 2)
#' S12 <- matrix(c(c(2, 0), c(0, 2)), nrow = 2, ncol = 2)
#' S22 <- matrix(c(c(-1, 0), c(0.5, -5)), nrow = 2, ncol = 2)
#' x <- matrix(c(c(0.5, 1), c(2, 1.5)), ncol = 2)
#' bivph_laplace(x, alpha, S11, S12, S22)
bivph_laplace <- function(r, alpha, S11, S12, S22) {
    .Call(`_phfrailty_bivph_laplace`, r, alpha, S11, S12, S22)
}

#' Derivative of order (n,m) of the joint Laplace of a bivariate phase-type
#'
#' @param r matrix of values
#' @param n order of first component
#' @param m order of second component
#' @param alpha vector of initial probabilities
#' @param S11 sub-intensity matrix
#' @param S12 matrix
#' @param S22 sub-intensity matrix
#' @return Derivative of joint laplace at \code{r}, without multiplicative constants
#' @export
#' @examples
#' alpha <- c(0.15, 0.85)
#' S11 <- matrix(c(c(-2, 9), c(0, -11)), nrow = 2, ncol = 2)
#' S12 <- matrix(c(c(2, 0), c(0, 2)), nrow = 2, ncol = 2)
#' S22 <- matrix(c(c(-1, 0), c(0.5, -5)), nrow = 2, ncol = 2)
#' x <- matrix(c(c(0.5, 1), c(2, 1.5)), ncol = 2)
#' bivph_laplace_der_nocons(x, 2, 3, alpha, S11, S12, S22)
bivph_laplace_der_nocons <- function(r, n, m, alpha, S11, S12, S22) {
    .Call(`_phfrailty_bivph_laplace_der_nocons`, r, n, m, alpha, S11, S12, S22)
}

#' Embedded Markov chain of a sub-intensity matrix
#'
#' Returns the transition probabilities of the embedded Markov chain determined the sub-intensity matrix
#' @param S sub-intensity matrix
#' @return the embedded Markov chain
#'
embedded_mc <- function(S) {
    .Call(`_phfrailty_embedded_mc`, S)
}

#' Cumulate matrix
#'
#' Creates a new matrix with entries the cumulated rows of \code{A}
#' @param A a matrix
#' @return the cumulated matrix
#'
cumulate_matrix <- function(A) {
    .Call(`_phfrailty_cumulate_matrix`, A)
}

#' Cumulate vector
#'
#' Creates a new vector with entries the cumulated entries of \code{A}
#' @param A a vector
#' @return the cumulated vector
#'
cumulate_vector <- function(A) {
    .Call(`_phfrailty_cumulate_vector`, A)
}

#' Initial state of Markov jump process
#'
#' Given the accumulated values of the initial probabilities \code{Pi} and a uniform value \code{u}, it returns the initial state of a Markov jump process
#' This corresponds to the states satisfying cum_pi_(k-1)<u<cum_pi_(k)
#' @param cum_pi a vector
#' @param u random value in (0,1)
#' @return initial state of the Markov jump process
#'
initial_state <- function(cum_pi, u) {
    .Call(`_phfrailty_initial_state`, cum_pi, u)
}

#' New state in a Markov jump process
#'
#' Given a transition matrix \code{Q}, a uniform value \code{u}, and a previous state \code{k}, it returns the new state of a Markov jump process
#' @param previous_state previous state of the Markov jump process
#' @param cum_embedded_mc transition matrix
#' @param u random value in (0,1)
#' @return next state of the Markov jump process
#'
new_state <- function(previous_state, cum_embedded_mc, u) {
    .Call(`_phfrailty_new_state`, previous_state, cum_embedded_mc, u)
}

#' Random phase-type
#'
#' Generates a sample of size \code{n} from a phase-type distribution with parameters \code{alpha} and \code{S}
#' @param n sample size
#' @param alpha vector of initial probabilities
#' @param S sub-intensity matrix
#' @return simulated sample
#' @export
#'
rphasetype <- function(n, alpha, S) {
    .Call(`_phfrailty_rphasetype`, n, alpha, S)
}

#' Clone a vector
#'
#' @param v a vector
#'
clone_vector <- function(v) {
    .Call(`_phfrailty_clone_vector`, v)
}

#' Clone a matrix
#'
#' @param m a matrix
#'
clone_matrix <- function(m) {
    .Call(`_phfrailty_clone_matrix`, m)
}

#' Random structure of a phase-type
#'
#' Generates random parameters \code{alpha} and \code{S} of a phase-type distribution of dimension \code{p} with chosen structure
#' @param p Dimension of the phase-type
#' @param structure Type of structure: "general", "hyperexponential", "gerlang", "coxian" or "gcoxian"
#' @param scale_factor A factor that multiplies the sub-intensity matrix
#' @return Random parameters \code{alpha} and \code{S} of a phase-type
#'
random_structure <- function(p, structure = "general", scale_factor = 1) {
    .Call(`_phfrailty_random_structure`, p, structure, scale_factor)
}

