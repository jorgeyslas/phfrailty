# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Discretization of a density
#'
#' Discretizates a density function using Simposon rule
#' @param density the density function
#' @param parameters parameters of the density function
#' @param truncation_point max value for the discretization
#' @param max_probability maximum probability of a discrete point
#' @param max_deltat maximum size of interval
#' @return List with values and weights
discretizate_density <- function(density, parameters, truncation_point, max_probability, max_deltat) {
    .Call(`_phfrailty_discretizate_density`, density, parameters, truncation_point, max_probability, max_deltat)
}

#' L_inf norm of a matrix
#'
#' Computes the inf norm of a matrix A, defined as
#' L-oo A =  max ( 1 <= I <= M ) sum ( 1 <= J <= N ) abs ( A(I,J) ).
#' @param A a matrix
#' @return The norm
#'
inf_norm <- function(A) {
    .Call(`_phfrailty_inf_norm`, A)
}

#' Matrix exponential algorithm
#'
#' MATLAB's built-in algorithm - Pade approximation
#' @param A a matrix
#' @return exp(A)
#'
matrix_exponential <- function(A) {
    .Call(`_phfrailty_matrix_exponential`, A)
}

#' Computes A^n
#'
#' @param A a matrix
#' @param n an integer
#' @return A^n
#' @export
matrix_power <- function(n, A) {
    .Call(`_phfrailty_matrix_power`, n, A)
}

#' Computes elements S^n until the value size
#' @param theVector a vector
#' @param S sub-intensity matrix
#' @param sizevect size of vector
vector_of_matrices <- function(theVector, S, sizevect) {
    invisible(.Call(`_phfrailty_vector_of_matrices`, theVector, S, sizevect))
}

#' Creates the matrix  (A1, B1 ; 0, A2)
#'
#' @param A1 a matrix
#' @param A2 a matrix
#' @param B1 a matrix
#' @return the matrix (A1, B1 ; 0, A2)
#'
matrix_VanLoan <- function(A1, A2, B1) {
    .Call(`_phfrailty_matrix_VanLoan`, A1, A2, B1)
}

#' EM using Matlab algorithm for matrix exponential in combination with Armadillo
#'
#' @param alpha initial probabilities
#' @param S sub-intensity
#' @param obs the observations
#' @param weight the weights for the observations
#' @return fitted alpha and S after one iteration
#' @export
EMstep_PADE <- function(alpha, S, obs, weight) {
    invisible(.Call(`_phfrailty_EMstep_PADE`, alpha, S, obs, weight))
}

#' EM  for bivariate PH using Matlab algorithm for matrix exponential
#'
#' @param alpha initial probabilities
#' @param S11 sub-intensity
#' @param S12 a matrix
#' @param S22 sub-intensity
#' @param obs the observations
#' @param weight the weights for the observations
#' @return fitted alpha, S11, S12 and S22 after one iteration
#' @export
EMstep_bivph <- function(alpha, S11, S12, S22, obs, weight) {
    invisible(.Call(`_phfrailty_EMstep_bivph`, alpha, S11, S12, S22, obs, weight))
}

#' Phase-type density
#'
#' Computes the density of a phase-type distribution with parameters \code{alpha} and \code{S} at \code{x}
#' @param x non-negative value
#' @param alpha vector of initial probabilities
#' @param S sub-intensity matrix
#' @return The density at \code{x}
#' @export
ph_density <- function(x, alpha, S) {
    .Call(`_phfrailty_ph_density`, x, alpha, S)
}

#' Phase-type cdf or tail
#'
#' Computes the cdf or tail of a phase-type distribution with parameters \code{alpha} and \code{S} at \code{x}
#' @param x non-negative values
#' @param alpha vector of initial probabilities
#' @param S sub-intensity matrix
#' @param lower_tail cdf or tail
#' @return The density at \code{x}
#' @export
ph_cdf <- function(x, alpha, S, lower_tail = TRUE) {
    .Call(`_phfrailty_ph_cdf`, x, alpha, S, lower_tail)
}

#' Laplace transform of a phase-type distribution
#'
#' Computes the Laplace transform at \code{r} of a phase-type distribution with parameters \code{alpha} and \code{S}
#' @param r real value
#' @param alpha vector of initial probabilities
#' @param S sub-intensity matrix
#' @return Laplace transform at \code{r}
#' @export
#' @examples
#' alpha <- c(0.5, 0.3, 0.2)
#' S <- matrix(c(c(-1, 0, 0), c(1, -2, 0),c(0, 1, -5)), nrow = 3, ncol = 3)
#' ph_laplace(0.5, alpha, S)
ph_laplace <- function(r, alpha, S) {
    .Call(`_phfrailty_ph_laplace`, r, alpha, S)
}

#' Derivative of order n of the Laplace transform of a phase-type distribution without the multiplying constant
#'
#' Computes the derivative of order n (without the multiplying constant) of the Laplace transform at \code{r} of a phase-type distribution with parameters \code{alpha} and \code{S}
#' @param r real value
#' @param n an integer
#' @param alpha vector of initial probabilities
#' @param S sub-intensity matrix
#' @return Laplace transform at \code{r}
#' @export
#' @examples
#' alpha <- c(0.5, 0.3, 0.2)
#' S <- matrix(c(c(-1, 0, 0), c(1, -2, 0),c(0, 1, -5)), nrow = 3, ncol = 3)
#' ph_laplace_der_nocons(0.5, 2, alpha, S)
ph_laplace_der_nocons <- function(r, n, alpha, S) {
    .Call(`_phfrailty_ph_laplace_der_nocons`, r, n, alpha, S)
}

#' Bivariate phase-type joint density
#'
#' @param x matrix of values
#' @param alpha vector of initial probabilities
#' @param S11 sub-intensity matrix
#' @param S12 matrix
#' @param S22 sub-intensity matrix
#' @return Joint density at \code{x}
#' @export
#' @examples
#' alpha <- c(0.15, 0.85)
#' S11 <- matrix(c(c(-2, 9), c(0, -11)), nrow = 2, ncol = 2)
#' S12 <- matrix(c(c(2, 0), c(0, 2)), nrow = 2, ncol = 2)
#' S22 <- matrix(c(c(-1, 0), c(0.5, -5)), nrow = 2, ncol = 2)
#' x <- matrix(c(c(0.5, 1), c(2, 1.5)), ncol = 2)
#' bivph_density(x, alpha, S11, S12, S22)
bivph_density <- function(x, alpha, S11, S12, S22) {
    .Call(`_phfrailty_bivph_density`, x, alpha, S11, S12, S22)
}

#' Bivariate phase-type joint tail
#'
#' @param x matrix of values
#' @param alpha vector of initial probabilities
#' @param S11 sub-intensity matrix
#' @param S12 matrix
#' @param S22 sub-intensity matrix
#' @return Joint tail at \code{x}
#' @export
#' @examples
#' alpha <- c(0.15, 0.85)
#' S11 <- matrix(c(c(-2, 9), c(0, -11)), nrow = 2, ncol = 2)
#' S12 <- matrix(c(c(2, 0), c(0, 2)), nrow = 2, ncol = 2)
#' S22 <- matrix(c(c(-1, 0), c(0.5, -5)), nrow = 2, ncol = 2)
#' x <- matrix(c(c(0.5, 1), c(2, 1.5)), ncol = 2)
#' bivph_tail(x, alpha, S11, S12, S22)
bivph_tail <- function(x, alpha, S11, S12, S22) {
    .Call(`_phfrailty_bivph_tail`, x, alpha, S11, S12, S22)
}

#' Bivariate phase-type joint Laplace
#'
#' @param r matrix of values
#' @param alpha vector of initial probabilities
#' @param S11 sub-intensity matrix
#' @param S12 matrix
#' @param S22 sub-intensity matrix
#' @return Joint laplace at \code{r}
#' @export
#' @examples
#' alpha <- c(0.15, 0.85)
#' S11 <- matrix(c(c(-2, 9), c(0, -11)), nrow = 2, ncol = 2)
#' S12 <- matrix(c(c(2, 0), c(0, 2)), nrow = 2, ncol = 2)
#' S22 <- matrix(c(c(-1, 0), c(0.5, -5)), nrow = 2, ncol = 2)
#' x <- matrix(c(c(0.5, 1), c(2, 1.5)), ncol = 2)
#' bivph_laplace(x, alpha, S11, S12, S22)
bivph_laplace <- function(r, alpha, S11, S12, S22) {
    .Call(`_phfrailty_bivph_laplace`, r, alpha, S11, S12, S22)
}

#' Derivative of order (n,m) of the joint Laplace of a bivariate phase-type
#'
#' @param r matrix of values
#' @param n order of first component
#' @param m order of second component
#' @param alpha vector of initial probabilities
#' @param S11 sub-intensity matrix
#' @param S12 matrix
#' @param S22 sub-intensity matrix
#' @return Derivative of joint laplace at \code{r}, without multiplicative constants
#' @export
#' @examples
#' alpha <- c(0.15, 0.85)
#' S11 <- matrix(c(c(-2, 9), c(0, -11)), nrow = 2, ncol = 2)
#' S12 <- matrix(c(c(2, 0), c(0, 2)), nrow = 2, ncol = 2)
#' S22 <- matrix(c(c(-1, 0), c(0.5, -5)), nrow = 2, ncol = 2)
#' x <- matrix(c(c(0.5, 1), c(2, 1.5)), ncol = 2)
#' bivph_laplace_der_nocons(x, 2, 3, alpha, S11, S12, S22)
bivph_laplace_der_nocons <- function(r, n, m, alpha, S11, S12, S22) {
    .Call(`_phfrailty_bivph_laplace_der_nocons`, r, n, m, alpha, S11, S12, S22)
}

